#Using fucking awk to parse dump stack line to a more readable format

#Get the absolute path of vmlinux
vmpath=`readlink -f $2`

#There is a case when .dump_temp already exists,used or  
#generated by others, however, I don't care, for this script is
#used by nobody except me, I'll be careful with it
rm -r .dump_temp
#Create a temp directory as a working place, seemss not so elegant.
mkdir .dump_temp
cp $1 .dump_temp
cd .dump_temp


#It's easy to think about using addr2line each time I meet a 
#mateched line, but this is fucking slow becasue everytime I
#use addr2line, it has to read vmlinux, whic is often about several
#hundreds of megaytes. I have to gather up these lines and use 
#addr2line only once, and this makes things much complicated. 

#Dump stack lines look like this 
# [   46.446182] [<ffffffc0000898a0>] dump_backtrace+0x0/0x270

#Get a cache file to mark those matched lines
awk '							\
{							\
	if(match($3,"\\[<[a-z0-9]{16}>\\]")) 		\
	{						\
		print NR				\
	}						\
	else						\
	{						\
		print NULL				\
	}						\
}' $1 >INDEX

#Get a cache file to save raw address
awk '							\
{							\
	if(match($3,"\\[<[a-z0-9]{16}>\\]")) 		\
	{						\
		print substr($3,3,16);			\
	}						\
}' $1 >ADDR

#Core part to parse these address
cat ADDR | addr2line -afp -e $vmpath > DUMP 

#i is an array of bool shows which line needs to be parsed and 
#replaced, b is an array holding the readable format lines
awk '	FILENAME=="INDEX"				\
{							\
	if($1){ i[FNR]=1 }				\
	else{i[FNR]=0}					\
}							\
	FILENAME=="DUMP"				\
{							\
	b[FNR]=$0					\
}							\
	FILENAME==ARGV[3]				\
{							\
	if( i[FNR]){					\
		dump++;					\
		print $1 "   " $2 " " b[dump] 		\
	}						\
	else{ print }					\
							\
}
' INDEX DUMP $1
cd ../
rm -rv .dump_temp
